<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Cardboard Example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #example {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
  </head>
  <body>
    <div id="example"></div>


  <script src="/socket.io/socket.io.js"></script>
  <!-- <script src="three.min.js"></script> -->
  <script src="three.js"></script>
  
  <script src="http://threejs.org/examples/js/loaders/OBJLoader.js"></script>
  <!--<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script> -->
  <script src="http://threejs.org/examples/js/libs/stats.min.js"></script>

  <script src="OrbitControls.js"></script>
  <script src="StereoEffect.js"></script>
  <script src="DeviceOrientationControls.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;
    var server = io.connect('http://alarrosa14.ddns.net:8080');

    /************************************************************/
    /* Interactions */
    var socket = io.connect('http://localhost:8080');
    socket.emit('interaction', { my: 'Interaction from Client' });
    /************************************************************/

    var clock = new THREE.Clock();

    init();

    fullscreen();

    loadPixelsFromXML('serverConf.xml', function(pixels){

      animate();
      render();

      server.on('frame', function(what){
      var bufView = new Uint8Array(what);

      for (var i = 0; i < 3*90; i =  i + 3) {
          var R = bufView[i];
          var G = bufView[i+1];
          var B = bufView[i+2]; 

          changePixelColor(pixels[i/3], R, G, B);
        }

        //render();
      });

    });

    function changePixelColor(object,r,g,b){

      colorRGB = (r << 16) | (g << 8) | b;
      object.traverse( function ( child ) {

        if ( child instanceof THREE.Mesh ) {
          child.material.color.set(colorRGB);
        }
      });
    }

    function init() {
      renderer = new THREE.WebGLRenderer({antialias: true});
      element = renderer.domElement;
      container = document.getElementById('example');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
      camera.position.set(0, 10, -200);
      scene.add(camera);

      controls = new THREE.OrbitControls(camera, element);
      controls.rotateUp(Math.PI / 4);
      controls.target.set(
        camera.position.x + 0.1,
        camera.position.y,
        camera.position.z
      );
      controls.noZoom = true;
      controls.noPan = true;

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);


      var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
      scene.add(light);

      var texture = THREE.ImageUtils.loadTexture(
        'textures/patterns/checker.png'
      );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat = new THREE.Vector2(50, 50);
      texture.anisotropy = renderer.getMaxAnisotropy();

      var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 20,
        shading: THREE.FlatShading,
        map: texture
      });

      var geometry = new THREE.PlaneGeometry(1000, 1000);

      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      //scene.add(mesh);

      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);
    }

    function addObject(objModel, position, up, front, RGBColor, objectGetter){

      var onProgress = function ( xhr ) {
      if ( xhr.lengthComputable ) {
        var percentComplete = xhr.loaded / xhr.total * 100;
        console.log( Math.round(percentComplete, 2) + '% downloaded' );
      }
      };

      var onError = function ( xhr ) {
      };

      var manager = new THREE.LoadingManager();

      manager.onProgress = function ( item, loaded, total ) {

        console.log( item, loaded, total );

      };

      var loader = new THREE.OBJLoader( manager );

      /////////////////////////////////////
      var obj;
      loader.load( objModel , function ( objectSrc ) {

        var object = objectSrc.clone();

        object.traverse( function ( child ) {

        if ( child instanceof THREE.Mesh ) {

          var material = new THREE.MeshBasicMaterial( { color: RGBColor, side : THREE.DoubleSide } );
          child.material = material;

        }

      } );

      front = front.normalize();
      up = up.normalize();

      var rotFront = new THREE.Matrix4();

      var qFront = new THREE.Quaternion();
      qFront.setFromUnitVectors(new THREE.Vector3(1,0,0),front);

      var newSourceUp = new THREE.Vector3(0,0,1); // hardcoded

      var qUp = new THREE.Quaternion();
      qUp.setFromUnitVectors(newSourceUp,up);

      var qTot = qFront;

      object.setRotationFromQuaternion(qTot);

      object.position.set(position.x,position.y,position.z);

      scene.add( object );

      objectGetter(object);
      }, onProgress, onError );

      /////////////////////////////////////////
    }

    function tagToVector3(tag){
      var x = parseFloat(tag.getAttribute('x'));
      var y = parseFloat(tag.getAttribute('y'));
      var z = parseFloat(tag.getAttribute('z'));
      return new THREE.Vector3(x,y,z);
    }

    function loadPixelsFromXML(xmlPath, callBack){

      var pixelsList = [];

      if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp=new XMLHttpRequest();
      }
      else{// code for IE6, IE5
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
      }

      xmlhttp.open("GET",xmlPath,false);
      xmlhttp.send();
      var xmlDoc=xmlhttp.responseXML;

      console.log(xmlDoc);

      var pixelsDoc = xmlDoc.getElementsByTagName("Pixel")
      var pixelsQty = pixelsDoc.length

      var loaderFunction = function(object){
        pixelsList.push(object);
        console.log("adding pixel...");
        if (pixelsList.length == pixelsQty){
          console.log("calling callback");
          callBack(pixelsList);
        }
      }

      for (var i = 0; i < pixelsDoc.length; i++) {

        var pixel = pixelsDoc[i]
        var R = parseInt(pixel.getAttribute('r'))
        var G = parseInt(pixel.getAttribute('g'))
        var B = parseInt(pixel.getAttribute('b'))

        var color = (R << 16) | (G << 8) | B;

        var renderTag = pixel.getElementsByTagName('Render')[0]

        var objectModelName = renderTag.getAttribute('mesh')

        var frontTag = renderTag.getElementsByTagName('Front')[0]
        var upTag = renderTag.getElementsByTagName('Up')[0]
        var positionTag = renderTag.getElementsByTagName('Position')[0]

        var front = tagToVector3(frontTag);
        var up = tagToVector3(upTag);
        var position = tagToVector3(positionTag);

        var print = function(vect){
          return '(' + vect.x + ',' + vect.y + ',' + vect.z + ')';
        }

        console.log('Pixel ' + i);
        console.log('front ' + print(front));
        console.log('up ' + print(up));
        console.log('position ' + print(position));

        addObject(objectModelName + '100.obj',position,up,front,color,loaderFunction);
      };
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();

      controls.update(dt);
    }

    function render(dt) {
      effect.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      update(clock.getDelta());
      render(clock.getDelta());
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }
  </script>
  </body>
</html>
